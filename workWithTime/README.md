# Работа с временем

## Таймаут операции

Можно реализовать через функцию time.After()

```
func withTimeout(fn func() int, timeout time.Duration) (int, error) {
	var result int

	done := make(chan struct{})
	go func() {
		result = fn()
		close(done)
	}()

	// <- done, если fn() успела до таймаута
	// <- time.After(), если прошло время
	select {
	case <-done:
		return result, nil
	case <-time.After(timeout):
		return 0, errors.New("timeout")
	}
}
```

## Таймер

Таймер используется если хочется выполнить действие не сейчас, а через какое-то время

```
var eventTime time.Time
timer := time.NewTimer(100 * time.Millisecond)
go func() {
    eventTime = <-timer.C
    fn()
}()
```

time.NewTime() создает новый таймер, который сработает через указанный промежуток времени. Таймер - это структура с каналом C, в который он запишет текущее время, когда сработает.

Таймер можно остановить. Тогда в канал C значение не придет и функция не запустится. Если он не успел сработать, то timer.Stop() вернет true. Если остановить слишком поздно, то false. В примере выше если остановить таймер, то горутина зависнет.

time.AfterFunc() позволяет запустить функцию через какое-то время. Функция также возвращает таймер, через который можно отменить выполнение. При этом горутина не зависнет

## Тикер (Ticker)

Тикер используется для того, чтобы выполнять какое-то действие с определенной периодичностью. Тикер срабатывает регулярно, пока его не остановить. Если его не остановить, то он не освободит занятые им ресурсы.

```
ticker := time.NewTicker(1 * time.Second)
defer ticker.Stop()

go func() {
    for {
        at := <-ticker.C
        fmt.Println(at)
    }
}()

time.Sleep(3 * time.Second)
```

