# Горутины

Функции, запущенные через `go` называются **горутинами (goroutine)**. Среда исполнения Go распределяет горутины по потокам операционной системы (threads), которые выполняются на разных ядрах CPU (CPU cores). По сравнению с потоками ОС, горутины очень легкие, так что их можно создавать сотнями и тысячами.

Если main() завершится прежде, чем успеют выполниться горутины, то программа не станет дожидаться выполнения горутин и завершит свое выполнение. Для этой проблемы есть несколько решений

## Группа ожидания (wait group)

```
// Вызов с горутинами
func UseWaitGroup() {
	var wg sync.WaitGroup

	start := time.Now()
	for range 4 {
		wg.Add(1)
		go func() {
			DoSomeWork("Work has been done using goroutine")
			wg.Done()
		}()
	}

	wg.Wait()
	fmt.Printf("Время с горутинами: %v \n", time.Since(start))
}
```

У `wg` есть счетчик. Вызывая `wg.Add(1)` мы увеличиваем его на единицу. `wg.Done()` уменьшает счетчик на единицу

`wg.Wait()` блокирует функцию, из которой была вызвана, до тех пор, пока счетчик не обнулится. Таким образом функция дожидается, пока отработают все горутины, после чего завершается 

## Канал завершения (done channel)

*Примечание: что такое каналы - расписано в следующем заголовке. Здесь описаны именно способы синхронизации*

```
func DoneChannelExample() {
	done := make(chan struct{})
	count := 4

	for range count {
		go func() {
			time.Sleep(1 * time.Second)
			fmt.Println("Work has been done")
			// Передаем в канал сигнал о завершении
			done <- struct{}{}
		}()
	}

	// Ждем выполнения всех горутин
	for range count {
		<-done
	}
}
```

Что здесь происходит:
1. Запускаем 4 горутины
2. Каждая горутина передает struct{}{} в канал завершения
3. Функция блокируется на этапе чтения из <- done

# Каналы

Каналы (channels) - способ обмениваться данными между горутинами

Передача значения через канал - синхронная операция. Когда горутина отправляет значение в канал, она блокируется и ждет, пока с другой стороны кто-нибудь не примет значение. Только после этого выполнение возобновится

Таким образом, каналы не только передают данные, но еще и могут использоваться для синхронизации горутин

```
func ChannelsExample1() {
	c := make(chan int)

	go func() {
		time.Sleep(1 * time.Second)
		// Отправляем значение в канал с задержкой
		c <- 5
	}()

	// Блокировка пока не будет получено значение из канала
	fmt.Printf("Число: %d", <-c)
}
```

## Закрытие канала

Есть писатель - пишет в канал
Есть читатель - читает из канала
Проблема: как писателю информировать читателя, что значения закончились?

Проблема решается через закрытие канала:

```
go func() {
    for i := 1; i < 3; i++ {
        in <- i
    }
    close(in)
}()
```

Чтение из закрытого канала вернет статус false вторым параметром:

```
res, ok = <-in
fmt.Printf("Число в канале: %d, статус канала: %v\n", res, ok)
```

Два важных правила:

1. Закрыть канал имеет право только писатель. Если читатель закроет канал, то писатель словит панику при попытке записи

2. Писатель имеет право закрыть канал, только если владеет им единолично. Если писателей несколько, и один из них закроет канал, то остальные словят панику при следующей записи или попытке закрыть канал

Закрывать канал стоит с единственной целью - сообщить читателям, что все данные отправлены. Если читателям это не важно - можно не закрывать, сборщик мусора Go освободит занятые им ресурсы

## Как эффективно проверять, что канал закрыт

Есть такая конструкция, работает в бесконечном цикле:

```
for {
    number, ok := <-in
    if !ok {
        break
    }
    fmt.Printf("%d ", number)
}
```

Вместо этого, можно читать из канала с помощью `range`. Паттерн выглядит следующим образом

```
for number := range in {
    fmt.Printf("%d ", number)
}
```

`range` автоматически считывает значение из канала и проверяет, не закрыт ли канал. Если закрыт, то выход из цикла. При этом `range` возвращать статус не будет. При итерировании по каналу возвращается только одно значение

## Направленные каналы

`chan` - для чтения и записи  
`chan<-` - только для записи  
`<-chan` - только для чтения

Благодаря такому подходу можно застраховаться от ошибок во время выполнения программы. В случае, если мы попытаемся записать значение в канал для чтения, то мы получим ошибку при компиляции. При этом закрывать receive-only каналы тоже нельзя

Каналы обычно инициализируют для чтения и записи, а в параметрах конкретных функций уже указывается направленность. Go конвертирует такие каналы в однонаправленный автоматически

## Буферизованные каналы

По умолчанию, если не указать размер буфера, то будет создан канал с размером 0

```
unbuffered := make(chan int)

buffered := make(chan int, 3)
```

На буферизованных каналах работают встроенные функции `len()` и `cap()`

# Deadlock

Deadlock возникает, когда одна горутина ждет вторую, а та ждет первую

```
func DeadlockExample() {
	out := make(chan int)
	done := make(chan struct{})

	go func() {
		for i := 1; i < 10; i++ {
			// Отправляется значение в канал и ожидается чтение
			out <- i
		}
		done <- struct{}{}
	}()

	// Ждем канал завершения. Блок
	<-done

	// Чтение из канала
	for number := range out {
		fmt.Println(number)
	}
}
```

Решением здесь будет реконструкция строчки `<-done`, ожидать завершения в горутине:

```
go func() {
    <-done
    close(out)
}()
```

## N-обработчиков - стандартная задача

Существует как минимум 2 способа решения задачи:

В этом примере используется буферизованный канал, который наполнен токенами. Как только появляется свободный токен - создается новая горутина. N токенов = N горутин
```
// Пример с запуском нескольких короткоживущих горутин
func BufferedChannelExample1() {
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}

	// N обработчиков = N горутин одновременно
	N := 2

	// Заполняем пул токенами
	pool := make(chan int, N)
	for i := 0; i < N; i++ {
		pool <- i
	}

	for _, num := range numbers {
		// Забираем токен и отдаем его горутине
		id := <-pool
		go func() {
			time.Sleep(1 * time.Second)
			fmt.Printf("Worker #%d: number %d \n", id, num)
			// Возвращаем токен
			pool <- id
		}()
	}

	// Ждем N обработчиков
	for range N {
		<-pool
	}
}
```

В этом примере создается горутина, которая передает значения в небуферизованный канал. Далее запускаются N обработчиков, которые читают канал. Как только канал будет прочитан полностью - цикл завершается и передается сигнал каналу завершения.
```
// Запускаются две долгие горутины, которые разгребают весь канал
func BufferedChannelExample2() {
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	done := make(chan struct{})

	pending := make(chan int)
	N := 2

	// Отправляем все элементы в один канал
	go func() {
		for _, num := range numbers {
			pending <- num
		}
		close(pending)
	}()

	// Запускаем N обработчиков
	for i := 0; i < N; i++ {
		go func() {
			for num := range pending {
				time.Sleep(1 * time.Second)
				fmt.Printf("Worker #%d: number %d \n", i, num)
			}
			done <- struct{}{}
		}()
	}

	// Ждем N обработчиков
	for range N {
		<-done
	}
}
```

## Закрытие буферизованного канала

Это безопасно. Отправитель может закрыть канал в любой момент и получатель точно их прочитает.

Считывание происходит в порядке очереди и в конце придет статус **false**

## nil-канал

nil-канал - неприятная вещь:
1. Запись в nil-канал навсегда блокирует горутину
2. Чтение из nil-канала навсегда блокирует горутину
3. Закрытие nil-канала приводит к панике